"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.convertMomentObjectToIsoDateString = exports.convertIsoDateStringToMomentObject = exports.getTypeByDayOfWeek = exports.localizeDates = exports.localize = exports.getLocale = exports.setLocale = void 0;

var _lodash = _interopRequireDefault(require("lodash"));

var _moment = _interopRequireDefault(require("moment"));

var _constants = require("../constants");

var Locales = _interopRequireWildcard(require("../locales"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

// Mustache style templating is easier on the eyes
_lodash["default"].templateSettings.interpolate = /{{([\s\S]+?)}}/g; // Set locale
// Locale lookup for date name strings are based on Moment.
// romcal defines at least the default 'en' language as a fallback.
// If a region is specified in the locale ('xx-XX'), romcal will
// automatically manage a graceful fallback to its base language ('xx'), if it exists in 'src/locales'.
// We get then a cascade fallbacks: region ('xx-XX') -> base language ('xx') -> default 'en'
// For example: if a string is missing in 'fr-CA', it will try to pick it in 'fr', and then in 'en'.

var _fallbackLocaleKey = 'en';

var _combinedLocale;

var _locales;

var setLocale = function setLocale(key) {
  // When setLocale() is called, it redefines this vars to defaults
  _combinedLocale = undefined;
  _locales = [_lodash["default"].get(Locales, _fallbackLocaleKey)]; // Sanitize incoming key

  key = _lodash["default"].toLower(key); // make key it lowercase

  var keyValues = /^([a-z]+)-?([a-z]*)/.exec(key); // extract lang and region from string

  var lang = keyValues[1];

  var region = _lodash["default"].toUpper(keyValues[2]); // make region it uppercase


  var localeName = lang + (region ? '-' + region : ''); // Use kebab-case in localName to follow IETF Language Codes standards

  key = lang + (region ? region : ''); // Set the Moment locale (if unrecognized, will default to 'en')

  _moment["default"].locale(localeName); // Ensures that the first day is always a Sunday in romcal & Moment.js
  // - Monday is the first day of the week according to the international standard ISO 8601,
  //   but in the US, Canada, and Japan, it's counted as the second day of the week.
  // - In Christian calendars, Sunday is always the first day of the week.


  _moment["default"].updateLocale(localeName, {
    week: {
      dow: 0
    }
  }); // If a region is specified: append the base language as fallback.
  // Also check if the base language isn't already the default 'en',
  // and if this base language exists in 'src/locales'


  if (!!region && lang !== _fallbackLocaleKey && _lodash["default"].has(Locales, lang)) {
    // Retrieve the relevant base locale object
    // and set it as a fallback (before 'en')
    _locales.unshift(_lodash["default"].get(Locales, lang));
  } // Set the given locale into romcal.
  // Also check if it's not the same as the fallback 'en'
  // (to avoid its duplicate definition)
  // and if exists in 'src/locales'


  if (key !== _fallbackLocaleKey && _lodash["default"].has(Locales, key)) {
    // Retrieve the relevant locale object
    // and set it as the first & default locale
    _locales.unshift(_lodash["default"].get(Locales, key));
  }
}; // Nested property lookup logic


exports.setLocale = setLocale;

var _getDescendantProp = function _getDescendantProp(obj, desc) {
  var arr = desc.split('.');

  while (arr.length && (obj = obj[arr.shift()])) {
    ;
  }

  return obj;
}; // Get the current locale object.
// Return an object that combines the main locale with its fallback.
// And use cache in case this function is called multiple times
// without the locale being modified.


var getLocale = function getLocale() {
  if (_lodash["default"].isUndefined(_combinedLocale)) {
    _combinedLocale = _lodash["default"].mergeWith.apply(null, [{}].concat(_lodash["default"].reverse(_locales)));
  }

  return _combinedLocale;
}; // Using the set Moment locale, get the relevant localized
// text for standard dates. Also make numbers ordinal by
// leveraging Moment's ordinal number function.


exports.getLocale = getLocale;

var localize = function localize(options) {
  var localeDate = _moment["default"].localeData();

  var value = _getDescendantProp(getLocale(), options.key); // If defined, pluralize a value and add it to the given template


  if (!_lodash["default"].isUndefined(options.week)) {
    options.week = localeDate.ordinal(options.week);
  } // If defined, count the nth day of the given series


  if (!_lodash["default"].isUndefined(options.count)) {
    options.count = localeDate.ordinal(options.count);
  } // Run the template against the options provided


  return _lodash["default"].template(value)(options);
}; // Utility function that takes an array of national calendar dates
// and adds a localized name based on the key


exports.localize = localize;

var localizeDates = function localizeDates(dates) {
  var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'sanctoral';
  return _lodash["default"].map(dates, function (d) {
    if (!_lodash["default"].has(d, 'drop')) {
      d.name = localize({
        key: "".concat(source, ".").concat(d.key)
      });
    }

    return d;
  });
};

exports.localizeDates = localizeDates;

var getTypeByDayOfWeek = function getTypeByDayOfWeek(d) {
  return _lodash["default"].eq(d, 0) ? _constants.Types.SUNDAY : _constants.Types.FERIA;
};

exports.getTypeByDayOfWeek = getTypeByDayOfWeek;

var convertMomentObjectToIsoDateString = function convertMomentObjectToIsoDateString() {
  var items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

  _lodash["default"].each(items, function (item, key) {
    // Loop through the date array
    if (_lodash["default"].has(item, 'moment')) {
      // check if it has a Moment property
      item.moment = item.moment.toISOString(); // and convert it to an ISO string
    } else {
      // this is a grouped result
      if (_lodash["default"].isArray(item)) {
        item = _lodash["default"].map(item, function (date) {
          if (_lodash["default"].has(date, 'moment')) {
            // check if it has a Moment property
            date.moment = date.moment.toISOString(); // and convert it to an ISO string
          }

          return date;
        });
      }
    }

    return item;
  });

  return items;
};

exports.convertMomentObjectToIsoDateString = convertMomentObjectToIsoDateString;

var convertIsoDateStringToMomentObject = function convertIsoDateStringToMomentObject() {
  var items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

  _lodash["default"].each(items, function (item, key) {
    // Loop through the date array
    if (_lodash["default"].has(item, 'moment')) {
      // check if it has a Moment property
      item.moment = _moment["default"].utc(item.moment); // and convert it to a Moment object
    } else {
      // this is a grouped result
      if (_lodash["default"].isArray(item)) {
        item = _lodash["default"].map(item, function (date) {
          if (_lodash["default"].has(date, 'moment')) {
            // check if it has a Moment property
            date.moment = _moment["default"].utc(date.moment); // and convert it to a Moment object
          }

          return date;
        });
      }
    }

    return item;
  });

  return items;
};

exports.convertIsoDateStringToMomentObject = convertIsoDateStringToMomentObject;