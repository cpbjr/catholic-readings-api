"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getCalendar = exports.countries = exports.queryFor = exports.calendarFor = void 0;

var _moment = _interopRequireDefault(require("moment"));

var _lodash = _interopRequireDefault(require("lodash"));

var Calendars = _interopRequireWildcard(require("../calendars"));

var Dates = _interopRequireWildcard(require("./Dates"));

var Utils = _interopRequireWildcard(require("./Utils"));

var Seasons = _interopRequireWildcard(require("./Seasons"));

var Celebrations = _interopRequireWildcard(require("./Celebrations"));

var _constants = require("../constants");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

// Get an array of country names
var countries = _lodash["default"].keys(Calendars); //================================================================================================
// Processing method for calendar config
//================================================================================================


exports.countries = countries;

var _sanitizeConfig = function _sanitizeConfig(config) {
  config = _lodash["default"].isPlainObject(config) ? config : _lodash["default"].stubObject();
  config.year = config.year || _moment["default"].utc().year();
  config.christmastideEnds = config.christmastideEnds || 'o'; // If the national calendar of Slovakia is requested and the flag to make Epiphany fall on Jan 6
  // is not specified, then default the flag to true because Slovakia always celebrates Epiphany of Jan 6.

  if (_lodash["default"].eq(config.country, 'slovakia') && _lodash["default"].isUndefined(config.epiphanyOnJan6)) {
    config.epiphanyOnJan6 = true;
  }

  config.epiphanyOnJan6 = config.epiphanyOnJan6 || false;
  config.christmastideIncludesTheSeasonOfEpiphany = config.christmastideIncludesTheSeasonOfEpiphany || true;
  config.corpusChristiOnThursday = config.corpusChristiOnThursday || false;
  config.ascensionOnSunday = config.ascensionOnSunday || false;
  config.country = config.country || ''; // Must be defaulted to empty string if not specified
  // CRUCIAL!! If country was passed as "general", reset it to an empty string

  if (_lodash["default"].eq(config.country, 'general')) {
    config.country = '';
  }

  config.locale = config.locale || 'en';
  config.type = config.type || 'calendar';
  config.query = _lodash["default"].isPlainObject(config.query) ? config.query : null;
  return config;
}; // Return the appropriate national calendar based on the country given
// Returns object with function returning empty array if nothing specified
// country: the camel cased country name to get the calendar for (country name will be camel cased in this method)


var getCalendar = function getCalendar(country) {
  if (country) {
    if (_lodash["default"].has(Calendars, _lodash["default"].camelCase(country))) {
      return Calendars[_lodash["default"].camelCase(country)];
    } else {
      return Calendars['general'];
    }
  }

  return {
    dates: function dates() {
      return [];
    }
  };
}; // Returns the merged national & general calendar dates
// along with key celebrations in the Roman Catholic rite
// Merges the national calendar to the general calendar
// where national calendar dates with the same key as a date
// in the general calendar will take precedence
// options: (see _calendarYear)


exports.getCalendar = getCalendar;

var _getCalendar = function _getCalendar(options) {
  // Get the general calendar based on the given year and format the result for better processing
  var general = getCalendar('general').dates(options.year); // Get the relevant national calendar object based on the given country

  var national = getCalendar(options.country).dates(options.year); // Check if 'drop' has been defined for any celebrations in the national calendar
  // and remove them from both national and general calendar sources

  var dropKeys = _lodash["default"].map(_lodash["default"].filter(national, function (n) {
    return _lodash["default"].has(n, 'drop') && n.drop;
  }), 'key');

  if (!_lodash["default"].isEmpty(dropKeys)) {
    _lodash["default"].each(dropKeys, function (dropKey) {
      // _,remove() mutates the array
      _lodash["default"].remove(general, function (_ref) {
        var key = _ref.key;
        return _lodash["default"].eq(key, dropKey);
      });

      _lodash["default"].remove(national, function (_ref2) {
        var key = _ref2.key;
        return _lodash["default"].eq(key, dropKey);
      });
    });
  } // format the general calendar for better processing and add the calendar source "g"


  general = _lodash["default"].reduce(general, function (r, v, k) {
    v.source = 'g';
    r[v.key] = v;
    return r;
  }, {}); // format the national calendar for better processing and add the calendar source "n"

  national = _lodash["default"].reduce(national, function (r, v, k) {
    v.source = 'n';
    r[v.key] = v;
    return r;
  }, {}); // If the national calendar has the same celebration defined
  // as in the general calendar, it replaces the one
  // in the general calendar
  // If the national calendar date is not in the general
  // calendar, it is added

  _lodash["default"].each(national, function (v, k) {
    return _lodash["default"].set(general, k, v);
  }); // Get the celebration dates based on the given year and options
  // and format the result for better processing


  var celebrations = _lodash["default"].reduce(Celebrations.dates(options.year, options.christmastideEnds, options.epiphanyOnJan6, options.corpusChristiOnThursday, options.ascensionOnSunday), function (r, v, k) {
    v.source = 'c';
    r[v.key] = v;
    return r;
  }, {}); // If the general calendar has the same celebration defined
  // check if it is prioritized, if not prioritized, it will
  // be overwritten by the incoming celebration date


  _lodash["default"].each(celebrations, function (v, k) {
    if (_lodash["default"].has(general, k)) {
      var date = _lodash["default"].get(general, k); // if the general date is not prioritized, it will be overwritten
      // by the celebration date


      if (!_lodash["default"].isUndefined(date.data) && !date.data.prioritized) {
        _lodash["default"].set(general, k, v);
      }
    } else {
      _lodash["default"].set(general, k, v);
    }
  }); // Merge coinciding dates based on this logic:
  //
  // Rule 1:
  // celebration dates have the highest priority
  // but if the national calendar has the same date
  // and is prioritized, it can replace the celebration date
  // celebration dates will always override general dates
  // only a national date may override a celebration
  //
  // Rule 2:
  // A national date can override a general date if the general
  // date is not prioritized. However if the general date is
  // prioritized, it will NOT be replaced by a national date that is
  // not prioritized
  // If both are prioritzed, the national date is kept
  //
  // Group dates by their moment values


  var result = _lodash["default"].groupBy(general, function (v) {
    return v.moment.valueOf();
  }); // Apply replacement logic for coinciding dates


  result = _lodash["default"].map(result, function (coincidences) {
    // Only run when there's more than 1 date in the group
    if (coincidences.length > 1) {
      // Group coincidences by their source
      var sources = _lodash["default"].groupBy(coincidences, function (v) {
        return v.source;
      }); // Flag of the date to be retained


      var keep; // If the group has
      // [1] a celebration
      // [2] no national date
      // [3] no general date
      // Keep the celebration and discard other coincidences

      if (_lodash["default"].has(sources, 'c') && !_lodash["default"].has(sources, 'n') && !_lodash["default"].has(sources, 'g')) {
        keep = 'c';
      } // If the group has
      // [1] a celebration
      // [2] a national date
      // [3] no general date
      // Keep national date IF its prioritized
      // else keep the celebration
      else if (_lodash["default"].has(sources, 'c') && _lodash["default"].has(sources, 'n')) {
          if (_lodash["default"].head(sources['n']).data.prioritized) {
            keep = 'n';
          } else {
            keep = 'c';
          }
        } // If the group has
        // [1] a national
        // [2] a general date
        // [3] no celebration
        // Keep the general date IF its prioritized
        // If not, keep the national date
        else if (!_lodash["default"].has(sources, 'c') && _lodash["default"].has(sources, 'n') && _lodash["default"].has(sources, 'g')) {
            if (!_lodash["default"].head(sources['n']).data.prioritized && _lodash["default"].head(sources['g']).data.prioritized) {
              keep = 'g';
            } else {
              keep = 'n';
            }
          } // If the group has multiple general dates ...
          // Step 1: Keep the one's that are prioritzed
          // Step 2: Keep the highest ranking general date
          else if (!_lodash["default"].has(sources, 'c') && !_lodash["default"].has(sources, 'n') && _lodash["default"].has(sources, 'g')) {
              // Get prioritized dates, if any
              var prioritizedDates = _lodash["default"].map(sources, function (source) {
                return _lodash["default"].filter(source, function (d) {
                  return d.data.prioritized;
                });
              });

              if (!_lodash["default"].isEmpty(prioritizedDates)) {
                // Pick highest ranking prioritized date
                coincidences = _lodash["default"].map(prioritizedDates, function (d) {
                  return _lodash["default"].minBy(d, function (item) {
                    return _lodash["default"].indexOf(_constants.Types, item.type);
                  });
                });
              } else {
                // If no prioritized dates found, simply pick the highest ranking date
                coincidences = _lodash["default"].map(sources, function (source) {
                  return _lodash["default"].minBy(source, function (item) {
                    return _lodash["default"].indexOf(_constants.Types, item.type);
                  });
                });
              }

              keep = 'g';
            } // If the group has a celebration and general date but no national date
            // and any other combination, keep the celebration date
            else {
                keep = 'c';
              } // Keep only the relevant date


      coincidences = _lodash["default"].filter(coincidences, {
        source: keep
      });
    }

    return coincidences;
  }); // Flatten the results

  result = _lodash["default"].flatten(result); // Remap the keys to be timestamps for better processing

  result = _lodash["default"].reduce(result, function (r, v, k) {
    // If the response already has this timestamp
    if (_lodash["default"].has(r, v.moment.valueOf())) {
      var date = _lodash["default"].get(r, v.moment.valueOf()); // If the incoming date has a higher rank than the current date


      if (_lodash["default"].lt(_lodash["default"].indexOf(_constants.Types, v.type), _lodash["default"].indexOf(_constants.Types, date.type))) {
        // Replace it with the incoming date
        r[v.moment.valueOf()] = v;
      }
    } else {
      // Response does not have this timestamp
      r[v.moment.valueOf()] = v;
    }

    return r;
  }, {});
  return result;
}; // options: (configuration options)
// dates: (liturgical dates array)


var _applyDates = function _applyDates(options, dates) {
  // Get the merged General and National Calendar dates
  var calendarDates = _getCalendar(options);

  var liturgicalDates = _lodash["default"].reduce(dates, function (r, v, k) {
    r[v.moment.valueOf()] = v;
    return r;
  }, {});

  dates = _lodash["default"].map(liturgicalDates, function (date, timestamp) {
    if (_lodash["default"].has(calendarDates, timestamp)) {
      var candidate = _lodash["default"].get(calendarDates, timestamp);

      var replace = false;
      var derank = false; //------------------------------------------------------------------
      // A celebration date will replace anything
      //------------------------------------------------------------------

      if (_lodash["default"].eq(candidate.source, 'c')) {
        replace = true;
      } //------------------------------------------------------------------
      // A general or national date needs further processing
      // before replacing something in the liturgical calendar
      //------------------------------------------------------------------
      else {
          //------------------------------------------------------------------
          // A SOLEMNITY will replace any date in the liturgical calendar
          // - solemnity must not override a solemnity in octave of EASTER
          //------------------------------------------------------------------
          if (_lodash["default"].eq(candidate.type, _constants.Types.SOLEMNITY) && _lodash["default"].gt(_lodash["default"].indexOf(_constants.Types, date.type), 0)) {
            replace = true;
          } //------------------------------------------------------------------
          // MEMORIAL or OPT_MEMORIAL that fall on a FERIA
          // in the SEASON OF LENT are reduced to a COMMEMORATION
          //------------------------------------------------------------------
          else if (_lodash["default"].eq(date.type, _constants.Types.FERIA) && _lodash["default"].eq(date.data.season.key, _constants.LiturgicalSeasons.LENT) && (_lodash["default"].eq(candidate.type, _constants.Types.MEMORIAL) || _lodash["default"].eq(candidate.type, _constants.Types.OPT_MEMORIAL))) {
              replace = true;
              derank = true;
            } //------------------------------------------------------------------
            // MEMORIAL or OPT_MEMORIAL that fall on a FERIA
            // outside LENT or the Easter Octave will replace the general FERIA
            //------------------------------------------------------------------
            else if (_lodash["default"].eq(date.type, _constants.Types.FERIA) // If the current date is of type feria
              && !_lodash["default"].eq(date.data.season.key, _constants.LiturgicalSeasons.LENT) // And this feria is not in Lent
              && (_lodash["default"].eq(candidate.type, _constants.Types.MEMORIAL) || _lodash["default"].eq(candidate.type, _constants.Types.OPT_MEMORIAL)) // And the candidate is either a memorial or optional memorial
              ) {
                  replace = true; // Then the candidate is fit to replace the feria
                } //------------------------------------------------------------------
                // A non prioritized FEAST can only replace FERIA \
                // - feria must not be in the octave of EASTER
                //------------------------------------------------------------------
              else if (_lodash["default"].eq(candidate.type, _constants.Types.FEAST) && _lodash["default"].eq(date.type, _constants.Types.FERIA) && !_lodash["default"].eq(date.data.season.key, _constants.LiturgicalSeasons.LENT) && !candidate.data.prioritized) {
                  replace = true;
                } //------------------------------------------------------------------
                // A FEAST occuring in the season of LENT is deranked
                // to a COMMEMORATION
                //------------------------------------------------------------------
                else if (_lodash["default"].eq(candidate.type, _constants.Types.FEAST) && _lodash["default"].eq(date.type, _constants.Types.FERIA) && _lodash["default"].eq(date.data.season.key, _constants.LiturgicalSeasons.LENT)) {
                    replace = true;
                    derank = true;
                  } //------------------------------------------------------------------
                  // A prioritized FEAST can replace a SUNDAY or FERIA
                  // When a Feast of the Lord falls on a SUNDAY it replaces the SUNDAY in Ordinary Time.
                  // - feria must not be in the octave of EASTER
                  //------------------------------------------------------------------
                  else if (_lodash["default"].eq(candidate.type, _constants.Types.FEAST) && (_lodash["default"].eq(date.type, _constants.Types.FERIA) || _lodash["default"].eq(date.type, _constants.Types.SUNDAY)) && !_lodash["default"].eq(date.data.season.key, _constants.LiturgicalSeasons.LENT) && candidate.data.prioritized) {
                      replace = true;
                    } //------------------------------------------------------------------
                    // A Sunday can only replace a Sunday
                    //------------------------------------------------------------------
                    else if (_lodash["default"].eq(date.type, _constants.Types.SUNDAY) && _lodash["default"].eq(candidate.type, _constants.Types.SUNDAY)) {
                        replace = true;
                      } //------------------------------------------------------------------
                      // A feria can only replace a feria
                      // Sundays in Ordinary Time and Chrismastide take precedence over all other celebrations
                      // except for SOLEMNITIES and certain FEASTS
                      //------------------------------------------------------------------
                      else if (_lodash["default"].eq(date.type, _constants.Types.FERIA) && _lodash["default"].eq(candidate.type, _constants.Types.FERIA)) {
                          replace = true;
                        } // Uncomment to see the dates that from the calendar that were not replaced
          // else {
          //   console.log('not replaced:', candidate.type, candidate.moment.format('L'), candidate.name );
          // }

        }

      if (replace) {
        date.key = candidate.key;
        date.name = candidate.name;
        date.source = candidate.source;
        date.type = derank ? _constants.Types.COMMEMORATION : candidate.type;
        date.data = _lodash["default"].merge({}, date.data, candidate.data);
      }
    }

    return date;
  });
  return dates;
}; //================================================================================================
// Include liturgical cycle metadata for the dates in the liturgical year
//================================================================================================
// year
// dates


var _liturgicalCycleMetadata = function _liturgicalCycleMetadata(year, dates) {
  // Formula to calculate lectionary cycle (Year A, B, C)
  var firstSundayOfAdvent = Dates.firstSundayOfAdvent(year);
  var thisCycle = (year - 1963) % 3;
  var nextCycle = _lodash["default"].eq(thisCycle, 2) ? 0 : thisCycle + 1;

  _lodash["default"].map(dates, function (v) {
    //=====================================================================
    // LITURGICAL CYCLES
    //---------------------------------------------------------------------
    // If the date is on or after the first sunday of advent
    // it is the next liturgical cycle
    //=====================================================================
    if (v.moment.isSame(firstSundayOfAdvent) || v.moment.isAfter(firstSundayOfAdvent)) {
      v.data.meta.cycle = {
        key: nextCycle,
        value: _constants.Cycles[nextCycle]
      };
    } else {
      v.data.meta.cycle = {
        key: thisCycle,
        value: _constants.Cycles[thisCycle]
      };
    }

    return v;
  });

  return dates;
}; //================================================================================================
// METHODS GENERATE THE ROMAN CALENDAR ACCORDING TO CALENDAR
// YEAR OR LITURGICAL YEAR
//================================================================================================
// Returns an object containing dates for the
// days that occur during the calendar year
// c: (an object literal with the following options)
// [-] year: The year to calculate the liturgical date ranges
// [-] country: Get national calendar dates for the given country (defaults to 'general')
// [-] locale: The language for the calendar names (defaults to 'en')
// [-] christmastideEnds: t|o|e (The mode to calculate the end of Christmastide. Defaukts to 'o')
// [-] epiphanyOnJan6: true|false|undefined (If true, Epiphany will be fixed to Jan 6) (defaults to false)
// [-] christmastideIncludesTheSeasonOfEpiphany: true|false|undefined (If false, the season of Epiphany will not be merged into Christmastide )
// [-] corpusChristiOnThursday: true|false|undefined (If true, Corpus Christi is set to Thursday) (defaults to false)
// [-] ascensionOnSunday: true|false|undefined (If true, Ascension is moved to the 7th Sunday of Easter) (defaults to false)
// [-] type: calendar|liturgical (return dates in either standard calendar or liturgical calendar format)
// [-] query: Additional filters to be applied against calendar dates array (default: none)


var _calendarYear = function _calendarYear(c) {
  // Get the liturgical seasons that run through the year
  var dates = _lodash["default"].union(Seasons.christmastide(c.year - 1, c.christmastideEnds, c.epiphanyOnJan6, c.christmastideIncludesTheSeasonOfEpiphany), Seasons.earlyOrdinaryTime(c.year, c.christmastideEnds, c.epiphanyOnJan6), Seasons.lent(c.year), Seasons.eastertide(c.year), Seasons.laterOrdinaryTime(c.year), Seasons.advent(c.year), Seasons.christmastide(c.year, c.christmastideEnds, c.epiphanyOnJan6, c.christmastideIncludesTheSeasonOfEpiphany)); // console.log(Seasons.lent(c.year));
  // Merge liturgical calendar dates with those from the general & national calendars


  dates = _applyDates(c, dates); // Filter dates within the given year only

  dates = _lodash["default"].filter(dates, function (d) {
    return _lodash["default"].eq(d.moment.year(), c.year);
  });
  dates = _liturgicalCycleMetadata(c.year, dates);
  return dates;
}; // Returns an object containing dates for the
// days that occur during the liturgical year
// c: (an object literal with the following options)
// [-] year: The year to calculate the liturgical date ranges
// [-] country: Get national calendar dates for the given country (defaults to 'general')
// [-] locale: The language for the calendar names (defaults to 'en')
// [-] christmastideEnds: t|o|e (The mode to calculate the end of Christmastide. Defaukts to 'o')
// [-] epiphanyOnJan6: true|false|undefined (If true, Epiphany will be fixed to Jan 6) (defaults to false)
// [-] christmastideIncludesTheSeasonOfEpiphany: true|false|undefined (If false, the season of Epiphany will not be merged into Christmastide )
// [-] corpusChristiOnThursday: true|false|undefined (If true, Corpus Christi is set to Thursday) (defaults to false)
// [-] ascensionOnSunday: true|false|undefined (If true, Ascension is moved to the 7th Sunday of Easter) (defaults to false)
// [-] type: calendar|liturgical (return dates in either standard calendar or liturgical calendar format)
// [-] query: Additional filters to be applied against calendar dates array (default: none)


var _liturgicalYear = function _liturgicalYear(c) {
  // Get dates for current year
  var thisYear = _calendarYear(c);

  var start = Dates.firstSundayOfAdvent(c.year); // Get dates for the following year

  c.year = c.year + 1;

  var nextYear = _calendarYear(c);

  var end = Dates.firstSundayOfAdvent(c.year); // Last day of liturgical year must be before this date

  var dates = _lodash["default"].union(_lodash["default"].filter(thisYear, function (v) {
    return v.moment.isSame(start) || v.moment.isAfter(start);
  }), _lodash["default"].filter(nextYear, function (v) {
    return v.moment.isBefore(end);
  }));

  return dates;
}; // Returns an array of liturgical dates based on the supplied calendar options
// The array may return dates according to the given calendar year or liturgical
// year depending on the options supplied
//
// If query object is passed:
// Return filtered liturgical calendar dates according to the given calendar options
// and filtering options passed in by the user
//
// config: calendar settings
//         if the config object has a query, it will be used to filter the
//         date results returned
//
// skipIsoConversion: undefined|true|false - skip converting moment objects to ISO8601 timestamp
//                    default action converts moment objects to ISO Strings
//


var calendarFor = function calendarFor() {
  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var skipIsoConversion = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  // If config is passed as a boolean
  // Then assume that we want the calendar for the current year
  // and either want to skip moment date ISO conversion or keep it
  // depending on the config value is true or false
  if (_lodash["default"].isBoolean(config)) {
    skipIsoConversion = config;
    config = {};
  } // If config is passed as an integer
  // Then assume we want the calendar for the current year


  if (_lodash["default"].isNumber(config)) {
    config = {
      year: config
    };
    skipIsoConversion = skipIsoConversion || false;
  } // Sanitize incoming config


  config = _sanitizeConfig(config); // Set the locale information

  Utils.setLocale(config.locale); // Get dates based on options

  var dates = _lodash["default"].eq(config.type, 'liturgical') ? _liturgicalYear(config) : _calendarYear(config); // Run queries, if any and return the results

  return queryFor(dates, config.query, skipIsoConversion);
}; // Filters an array of dates generated from the calendarFor function based on a given query.
// dates: An array of dates generated from the calendarFor function
// query: An object containing keys to filter the dates by
// skipIsoConversion: undefined|true|false - skip converting moment objects to ISO8601 timestamp
//                    default action converts moment objects to ISO Strings


exports.calendarFor = calendarFor;

var queryFor = function queryFor() {
  var dates = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var query = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var skipIsoConversion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  if (!_lodash["default"].every(dates, _lodash["default"].isObject)) {
    throw 'romcal.queryFor can only accept a single dimenional array of objects';
  } //==========================================================================
  // Check if there is a query defined, if none return the unfiltered
  // calendar array
  //==========================================================================


  if (!_lodash["default"].isNull(query) && !_lodash["default"].isEmpty(query)) {
    // Reparse dates into moment objects if needed
    dates = Utils.convertIsoDateStringToMomentObject(dates); // Months are zero indexed, so January is month 0.

    if (_lodash["default"].has(query, 'month')) {
      dates = _lodash["default"].filter(dates, function (d) {
        return _lodash["default"].eq(d.moment.month(), _lodash["default"].get(query, 'month'));
      });
    }

    if (_lodash["default"].has(query, 'day')) {
      dates = _lodash["default"].filter(dates, function (d) {
        return _lodash["default"].eq(d.moment.day(), _lodash["default"].get(query, 'day'));
      });
    }

    if (_lodash["default"].has(query, 'title')) {
      dates = _lodash["default"].filter(dates, function (d) {
        return _lodash["default"].includes(d.data.meta.titles, _lodash["default"].get(query, 'title'));
      });
    }

    if (_lodash["default"].has(query, 'group')) {
      switch (_lodash["default"].get(query, 'group')) {
        case 'days':
          dates = _lodash["default"].groupBy(dates, function (d) {
            return d.moment.day();
          });
          break;

        case 'months':
          dates = _lodash["default"].groupBy(dates, function (d) {
            return d.moment.month();
          });
          break;

        case 'daysByMonth':
          dates = _lodash["default"].groupBy(dates, function (d) {
            return d.moment.month();
          });
          dates = _lodash["default"].map(dates, function (v) {
            return _lodash["default"].groupBy(v, function (d) {
              return d.moment.day();
            });
          });
          break;

        case 'weeksByMonth':
          dates = _lodash["default"].groupBy(dates, function (d) {
            return d.moment.month();
          });
          dates = _lodash["default"].map(dates, function (v) {
            return _lodash["default"].groupBy(v, function (d) {
              return d.data.calendar.week;
            });
          });
          break;

        case 'cycles':
          dates = _lodash["default"].groupBy(dates, function (d) {
            return d.data.meta.cycle.value;
          });
          break;

        case 'types':
          dates = _lodash["default"].groupBy(dates, function (d) {
            return d.type;
          });
          break;

        case 'liturgicalSeasons':
          dates = _lodash["default"].groupBy(dates, function (d) {
            return d.data.season.key;
          }); // console.log('dates', dates );

          break;

        case 'liturgicalColors':
          dates = _lodash["default"].groupBy(dates, function (d) {
            return d.data.meta.liturgicalColor.key;
          });
          break;

        case 'psalterWeek':
          dates = _lodash["default"].groupBy(dates, function (d) {
            return d.data.meta.psalterWeek.key;
          });
          break;

        default:
          break;
      }
    }
  } // If undefined or false, continue with conversion


  if (!skipIsoConversion) {
    dates = Utils.convertMomentObjectToIsoDateString(dates);
  }

  return dates;
};

exports.queryFor = queryFor;